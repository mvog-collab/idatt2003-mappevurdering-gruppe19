package edu.ntnu.idatt2003.presentation.ludo.controller;

import edu.games.engine.model.LudoColor;
import edu.ntnu.idatt2003.gateway.CompleteBoardGame;
import edu.ntnu.idatt2003.gateway.LudoGateway;
import edu.ntnu.idatt2003.gateway.view.PlayerView;
import edu.ntnu.idatt2003.presentation.common.controller.AbstractGameController;
import edu.ntnu.idatt2003.presentation.ludo.view.LudoBoardView;
import edu.ntnu.idatt2003.utils.Errors;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * Controller for managing Ludo board game interactions and gameplay logic.
 * <p>
 * This controller handles all aspects of Ludo gameplay including dice rolling,
 * piece selection, movement validation, turn management, and UI updates. It
 * serves
 * as the intermediary between the game model and the board view, managing
 * game state changes and ensuring proper game flow according to Ludo rules.
 * </p>
 */
public final class LudoBoardController extends AbstractGameController<LudoBoardView> {

  private int lastRolledValue = 0;
  private int selectedPieceIndex = -1;
  private boolean waitingForPieceSelection = false;
  private static final int GOAL_LENGTH = 5;
  private static final Logger LOG = Logger.getLogger(LudoBoardController.class.getName());

  /**
   * Constructs a new LudoBoardController with the specified view and gateway.
   * <p>
   * Initializes the controller by setting up piece selection callbacks and
   * refreshing the initial game state. Any initialization errors are logged
   * and handled appropriately.
   * </p>
   *
   * @param view    the LudoBoardView to control and update
   * @param gateway the game gateway providing access to game logic and state
   */
  public LudoBoardController(LudoBoardView view, CompleteBoardGame gateway) {
    super(view, gateway);
    LOG.info("LudoBoardController initialized.");
    try {
      view.setPieceSelectedCallback(this::onPieceSelected);
      refreshTokens();
    } catch (Exception e) {
      LOG.log(Level.SEVERE, "Error during LudoBoardController initialization", e);
      Errors.handle("Failed to initialize Ludo board controller.", e);
    }
  }

  /**
   * Handles dice rolling action initiated by the current player.
   * <p>
   * This method processes the dice roll, determines available moves based on
   * the rolled value and current game state, and manages the subsequent game
   * flow. Special handling is provided for rolls of 6, which allow pieces
   * to move from home and grant additional turns.
   * </p>
   * 
   * <p>
   * This method was generated by ChatGBT and changed to fit our structure with
   * logging.
   * </p>
   */
  @Override
  protected void onRollDice() {
    LOG.info("Roll dice action initiated.");
    view.disableRollButton();

    PlayerView currentPlayer = getCurrentPlayer();
    if (currentPlayer == null) {
      LOG.warning("onRollDice called but no current player found. Enabling roll button.");
      view.enableRollButton();
      return;
    }
    LOG.info("Current player for dice roll: " + currentPlayer.playerName());

    try {
      lastRolledValue = gateway.rollDice();
      view.showDice(lastRolledValue);
      LOG.log(Level.INFO, () -> currentPlayer.playerName() + " rolled: " + lastRolledValue);

      LudoColor color = LudoColor.valueOf(currentPlayer.playerToken());
      boolean hasHomePieces = playerHasPiecesAtHome(currentPlayer);
      boolean hasMoveableBoardPieces = playerHasMoveablePiecesOnBoard(currentPlayer, color);

      if (lastRolledValue == 6) {
        handleRollOfSix(currentPlayer, hasHomePieces, hasMoveableBoardPieces);
      } else {
        handleNormalRoll(currentPlayer, hasMoveableBoardPieces, hasHomePieces);
      }
    } catch (IllegalArgumentException e) {
      LOG.log(Level.WARNING, "Invalid LudoColor token for player: " + currentPlayer.playerToken(), e);
      view.showAlert("Game Error", "Invalid player color detected. Cannot proceed.");
      view.enableRollButton();
    } catch (Exception e) {
      LOG.log(Level.SEVERE, "Error during dice roll processing for player " + currentPlayer.playerName(), e);
      Errors.handle("An error occurred while processing the dice roll.", e);
      view.enableRollButton(); // Try to allow user to recover or try again
    }
  }

  /**
   * Determines if a player has any pieces still at home (starting position).
   *
   * @param player the player to check
   * @return true if the player has at least one piece at home (position <= 0)
   */
  private boolean playerHasPiecesAtHome(PlayerView player) {
    return player.piecePositions().stream().anyMatch(pos -> pos <= 0);
  }

  /**
   * Determines if a player has any moveable pieces on the board.
   * <p>
   * A piece is considered moveable if it's on the board (position > 0)
   * and hasn't reached the final goal position.
   * </p>
   *
   * @param player the player to check
   * @param color  the player's color for goal position calculation
   * @return true if the player has at least one moveable piece on the board
   */
  private boolean playerHasMoveablePiecesOnBoard(PlayerView player, LudoColor color) {
    return player.piecePositions().stream()
        .anyMatch(pos -> pos > 0 && !isPieceFinished(pos, color));
  }

  /**
   * Handles the special case when a player rolls a 6.
   * <p>
   * Rolling a 6 allows pieces to move from home and grants an additional turn.
   * This method manages piece selection options and UI feedback for this
   * scenario.
   * </p>
   *
   * @param currentPlayer          the player who rolled the dice
   * @param hasHomePieces          whether the player has pieces at home
   * @param hasMoveableBoardPieces whether the player has moveable pieces on board
   */
  private void handleRollOfSix(
      PlayerView currentPlayer, boolean hasHomePieces, boolean hasMoveableBoardPieces) {
    LOG.info(
        currentPlayer.playerName() + " rolled a 6. Has home pieces: " + hasHomePieces + ", Has moveable board pieces: "
            + hasMoveableBoardPieces);
    waitingForPieceSelection = true;
    if (hasHomePieces) {
      view.showStatusMessage(
          currentPlayer.playerName() + " rolled a 6! Select a piece to move (can move from home).");
    } else if (hasMoveableBoardPieces) {
      view.showStatusMessage(currentPlayer.playerName() + " rolled a 6! Select a piece to move.");
      tryAutoSelectOnlyMovablePiece(currentPlayer);
    } else {
      LOG.warning(currentPlayer.playerName()
          + " rolled a 6 but has no valid moves. All pieces might be finished or in an unexpected state.");
      view.showStatusMessage(
          currentPlayer.playerName() + " rolled a 6 but has no valid moves (all pieces finished?).");
      view.enableRollButton();
    }
  }

  /**
   * Handles normal dice rolls (values 1-5).
   * <p>
   * For normal rolls, only pieces already on the board can be moved.
   * If no valid moves are available, the turn is automatically skipped.
   * </p>
   *
   * @param currentPlayer          the player who rolled the dice
   * @param hasMoveableBoardPieces whether the player has moveable pieces on board
   * @param hasHomePieces          whether the player has pieces at home
   */
  private void handleNormalRoll(
      PlayerView currentPlayer, boolean hasMoveableBoardPieces, boolean hasHomePieces) {
    LOG.info(
        currentPlayer.playerName() + " rolled " + lastRolledValue + ". Has moveable board pieces: "
            + hasMoveableBoardPieces);
    if (hasMoveableBoardPieces) {
      waitingForPieceSelection = true;
      view.showStatusMessage(currentPlayer.playerName() + " - select a piece to move.");
      tryAutoSelectOnlyMovablePiece(currentPlayer);
    } else {
      handleNoValidMoves(currentPlayer, hasHomePieces);
    }
  }

  /**
   * Attempts to automatically select a piece if the player has only one valid
   * option.
   * <p>
   * This optimization improves user experience by automatically proceeding
   * when there's only one possible move, eliminating unnecessary clicks.
   * </p>
   *
   * @param currentPlayer the player whose pieces to check
   */
  private void tryAutoSelectOnlyMovablePiece(PlayerView currentPlayer) {
    try {
      LudoColor color = LudoColor.valueOf(currentPlayer.playerToken());
      List<Integer> boardPieceIndices = getBoardPieceIndices(currentPlayer, color);
      if (boardPieceIndices.size() == 1) {
        selectedPieceIndex = boardPieceIndices.get(0);
        LOG.log(Level.INFO, () -> "Auto-selecting piece: " + selectedPieceIndex +
            " for " + currentPlayer.playerName());
        processSelectedPiece();
      }
    } catch (IllegalArgumentException e) {
      LOG.log(Level.WARNING, "Invalid LudoColor token for auto-selection: " + currentPlayer.playerToken(), e);
    }
  }

  /**
   * Handles the case when a player has no valid moves.
   * <p>
   * If the player has pieces at home but rolled a non-6, their turn is
   * automatically skipped. The method manages the appropriate game state
   * transitions and UI updates.
   * </p>
   *
   * @param currentPlayer the player with no valid moves
   * @param hasHomePieces whether the player has pieces at home
   */
  private void handleNoValidMoves(PlayerView currentPlayer, boolean hasHomePieces) {
    LOG.log(Level.INFO, () -> currentPlayer.playerName() + " has no valid moves with roll " + lastRolledValue);
    view.showStatusMessage(currentPlayer.playerName() + " has no valid moves.");

    if (hasHomePieces && gateway instanceof LudoGateway ludoGw) {
      for (int i = 0; i < currentPlayer.piecePositions().size(); i++) {
        if (currentPlayer.piecePositions().get(i) <= 0) {
          selectedPieceIndex = i;
          break;
        }
      }
      ludoGw.selectPiece(selectedPieceIndex);
      ludoGw.applyPieceMovement();
      selectedPieceIndex = -1;
      waitingForPieceSelection = false;
      refreshTokens();
    }
    view.enableRollButton();
  }

  /**
   * Gets the indices of all moveable pieces on the board for a player.
   * <p>
   * A piece is considered moveable if it's on the board (position > 0)
   * and hasn't finished the game.
   * </p>
   *
   * @param player the player whose pieces to check
   * @param color  the player's color for goal calculation
   * @return list of indices of moveable pieces
   */
  private List<Integer> getBoardPieceIndices(PlayerView player, LudoColor color) {
    List<Integer> indices = new ArrayList<>();
    for (int i = 0; i < player.piecePositions().size(); i++) {
      int pos = player.piecePositions().get(i);
      if (pos > 0 && !isPieceFinished(pos, color)) {
        indices.add(i);
      }
    }
    return indices;
  }

  /**
   * Handles piece selection events from the user interface.
   * <p>
   * Validates the selection against current game rules and processes
   * the move if valid. Invalid selections trigger appropriate user feedback.
   * </p>
   *
   * @param pieceIndex the index of the selected piece
   */
  private void onPieceSelected(int pieceIndex) {
    LOG.fine("Piece selected by user: index " + pieceIndex);
    if (!waitingForPieceSelection) {
      LOG.fine("Not waiting for piece selection. Ignoring click on piece " + pieceIndex);
      return;
    }

    PlayerView currentPlayer = getCurrentPlayer();
    if (currentPlayer == null) {
      LOG.warning("Piece selected but no current player. Ignoring click.");
      return;
    }
    LOG.info("Piece " + pieceIndex + " selected by player " + currentPlayer.playerName());

    try {
      if (!isValidPieceSelection(currentPlayer, pieceIndex, lastRolledValue)) {
        LOG.warning("Invalid piece selection: piece " + pieceIndex + " by " + currentPlayer.playerName() + " with roll "
            + lastRolledValue);
        return;
      }
      selectedPieceIndex = pieceIndex;
      processSelectedPiece();
    } catch (Exception e) {
      LOG.log(Level.SEVERE,
          "Error processing piece selection for player " + currentPlayer.playerName() + ", piece " + pieceIndex, e);
      Errors.handle("An error occurred while selecting the piece.", e);
      // Reset state to be safe
      waitingForPieceSelection = false;
      view.enableRollButton();
    }
  }

  /**
   * Validates whether a piece selection is valid given current game rules.
   * <p>
   * Checks include bounds validation, home piece movement rules (requires 6),
   * and finished piece restrictions.
   * </p>
   *
   * @param player      the player making the selection
   * @param pieceIndex  the index of the selected piece
   * @param currentRoll the current dice roll value
   * @return true if the selection is valid, false otherwise
   */
  private boolean isValidPieceSelection(PlayerView player, int pieceIndex, int currentRoll) {
    if (pieceIndex >= player.piecePositions().size() || pieceIndex < 0) {
      view.showAlert("Invalid Selection", "Selected piece index is out of bounds.");
      return false;
    }

    int position = player.piecePositions().get(pieceIndex);
    LudoColor color = LudoColor.valueOf(player.playerToken());

    if (position <= 0 && currentRoll != 6) {
      view.showAlert("Invalid Move", "You need to roll a 6 to move a piece from home.");
      return false;
    }
    if (isPieceFinished(position, color)) {
      view.showAlert("Piece Finished", "That piece has already reached the goal.");
      return false;
    }
    return true;
  }

  /**
   * Processes the selected piece movement through the game gateway.
   * <p>
   * Coordinates with the game model to execute the move, handles position
   * changes, triggers appropriate animations, and manages post-move game state.
   * </p>
   * 
   * <p>
   * This method was generated by ChatGBT and changed to fit our structure with
   * logging.
   * </p>
   */
  private void processSelectedPiece() {
    LOG.info("Processing selected piece: index " + selectedPieceIndex);
    view.disableRollButton();
    waitingForPieceSelection = false;

    PlayerView currentPlayer = getCurrentPlayer();
    if (currentPlayer == null || selectedPieceIndex < 0) {
      LOG.warning("processSelectedPiece called with no current player or invalid selectedPieceIndex. Current player: "
          + (currentPlayer != null ? currentPlayer.playerName() : "null") + ", selectedPieceIndex: "
          + selectedPieceIndex);
      view.enableRollButton();
      return;
    }

    String playerColorToken = currentPlayer.playerToken();
    int initialPosition = currentPlayer.piecePositions().get(selectedPieceIndex);
    LOG.info("Player " + currentPlayer.playerName() + " moving piece " + selectedPieceIndex + " from " + initialPosition
        + " with roll " + lastRolledValue);

    try {
      if (gateway instanceof LudoGateway ludoGw) {
        ludoGw.selectPiece(selectedPieceIndex);
        ludoGw.applyPieceMovement();
      } else {
        LOG.severe("Gateway is not an instance of LudoGateway. Cannot apply Ludo-specific piece movement.");
        view.showAlert("Critical Error", "Game logic error. Cannot move piece.");
        resetAndEnableRoll();
        return;
      }

      PlayerView playerAfterMove = gateway.players().stream()
          .filter(p -> p.playerToken().equals(playerColorToken))
          .findFirst()
          .orElse(null);

      if (playerAfterMove == null) {
        LOG.severe("Player " + playerColorToken + " not found after move. This should not happen.");
        resetAndEnableRoll();
        return;
      }

      int finalPosition = playerAfterMove.piecePositions().get(selectedPieceIndex);
      LOG.info("Piece " + selectedPieceIndex + " for " + playerColorToken + " moved to " + finalPosition);
      PlayerView newCurrentPlayer = getCurrentPlayer();
      boolean playerKeepsTurn = newCurrentPlayer != null && newCurrentPlayer.playerToken().equals(playerColorToken);

      boolean movedFromHomeToStart = initialPosition <= 0 && finalPosition > 0 && lastRolledValue == 6;

      if (movedFromHomeToStart) {
        animatePieceFromHome(playerColorToken, selectedPieceIndex, finalPosition, playerKeepsTurn);
      } else if (initialPosition != finalPosition) {
        animatePieceOnBoard(
            playerColorToken, selectedPieceIndex, initialPosition, finalPosition, playerKeepsTurn);
      } else {
        LOG.info("Piece " + selectedPieceIndex + " for " + playerColorToken
            + " did not change position (e.g., blocked or no valid move from gateway).");
        handlePostMoveUI(playerColorToken, playerKeepsTurn);
      }

    } catch (Exception e) {
      LOG.log(Level.SEVERE, "Error during piece movement processing for player " + currentPlayer.playerName(), e);
      Errors.handle("An error occurred while moving the piece.", e);
      handlePostMoveUI(playerColorToken,
          getCurrentPlayer() != null && getCurrentPlayer().playerToken().equals(playerColorToken));
    } finally {
      selectedPieceIndex = -1;
    }
  }

  /**
   * Animates a piece moving from home to its starting position on the board.
   * <p>
   * This special animation handles the transition from the home area to
   * the board entry point when a player rolls a 6.
   * </p>
   *
   * @param playerToken        the token/color of the player
   * @param pieceIdx           the index of the piece being moved
   * @param endPositionOnBoard the final position on the board
   * @param playerKeepsTurn    whether the player retains their turn
   */
  private void animatePieceFromHome(
      String playerToken, int pieceIdx, int endPositionOnBoard, boolean playerKeepsTurn) {
    List<Integer> path = List.of(0, endPositionOnBoard); // 0 represents home visually

    view.animateMoveAlongPath(
        playerToken, pieceIdx, path, () -> handlePostMoveUI(playerToken, playerKeepsTurn));
  }

  /**
   * Animates a piece moving along the board from one position to another.
   * <p>
   * Calculates the full path between positions and triggers the animation
   * with appropriate completion handling.
   * </p>
   *
   * @param playerToken     the token/color of the player
   * @param pieceIdx        the index of the piece being moved
   * @param startPos        the starting position on the board
   * @param endPos          the ending position on the board
   * @param playerKeepsTurn whether the player retains their turn
   */
  private void animatePieceOnBoard(
      String playerToken, int pieceIdx, int startPos, int endPos, boolean playerKeepsTurn) {
    List<Integer> path = buildLudoPathBetween(startPos, endPos, LudoColor.valueOf(playerToken));
    LOG.log(Level.WARNING, () -> "Animating piece " + pieceIdx + " for " + playerToken + " along path: " + path);

    view.animateMoveAlongPath(
        playerToken, pieceIdx, path, () -> handlePostMoveUI(playerToken, playerKeepsTurn));
  }

  /**
   * Handles UI updates after a piece movement animation completes.
   * <p>
   * Updates game state, checks for winners, manages turn transitions,
   * and provides appropriate user feedback based on game outcomes.
   * </p>
   *
   * @param playerMovedToken the token of the player who moved
   * @param playerKeepsTurn  whether the moving player retains their turn
   */
  private void handlePostMoveUI(String playerMovedToken, boolean playerKeepsTurn) {
    refreshTokens();

    if (gateway.hasWinner()) {
      gateway.players().stream()
          .filter(
              p -> p.playerToken().equals(playerMovedToken))
          .findFirst()
          .ifPresent(winner -> view.announceWinner(winner.playerName()));
    } else {
      PlayerView actualCurrentPlayer = getCurrentPlayer();
      if (actualCurrentPlayer == null) {
        view.disableRollButton();
        return;
      }

      if (playerKeepsTurn) {
        view.enableRollButton();
        view.showStatusMessage(actualCurrentPlayer.playerName() + "'s turn continues - roll again!");
      } else {
        view.showStatusMessage(actualCurrentPlayer.playerName() + "'s turn - please roll");
        view.enableRollButton();
      }
    }
  }

  /**
   * Resets the controller state and enables the roll button.
   * <p>
   * Used for error recovery and state cleanup when operations fail.
   * </p>
   */
  private void resetAndEnableRoll() {
    refreshTokens();
    view.enableRollButton();
    selectedPieceIndex = -1;
    waitingForPieceSelection = false;
  }

  /**
   * Builds a path of position IDs for animating piece movement.
   * <p>
   * Calculates the step-by-step path a piece must take to move from
   * start to end position, considering Ludo board topology, goal areas,
   * and color-specific movement rules.
   * </p>
   * 
   * <p>
   * This method was generated by ChatGBT and changed to fit our structure with
   * logging.
   * </p>
   *
   * @param startId the starting position ID
   * @param endId   the ending position ID
   * @param color   the player color for path calculation
   * @return ordered list of position IDs representing the movement path
   */
  private List<Integer> buildLudoPathBetween(int startId, int endId, LudoColor color) {
    List<Integer> path = new ArrayList<>();
    path.add(startId);

    if (startId == endId) {
      return path;
    }

    int currentSimulatedId = startId;
    int ownerEntryPointId = getEntryPoint(color);
    int ownerPreEntryPointId = (ownerEntryPointId == 1) ? 52 : ownerEntryPointId - 1;
    int goalBaseForColor = getGoalBaseId(color);
    int goalEndForColor = goalBaseForColor + GOAL_LENGTH - 1;
    for (int step = 0; step < 70 && currentSimulatedId != endId; step++) {
      int nextSimulatedId = -1;

      if (currentSimulatedId == 0) {
        nextSimulatedId = ownerEntryPointId;
        if (endId == ownerEntryPointId) {
        } else if (endId > 0 && endId <= 52 && endId != ownerEntryPointId) {
          LOG.log(Level.WARNING, "Pathing from home to a non-entry point: " + endId + ". Animating to entry first.");
        } else if (endId >= goalBaseForColor && endId <= goalEndForColor) {
          LOG.log(Level.WARNING, "Pathing from home directly into goal: " + endId + ". Animating to entry first.");
        }

      } else if (currentSimulatedId >= goalBaseForColor && currentSimulatedId < goalEndForColor) {
        if (currentSimulatedId < endId && endId <= goalEndForColor) {
          nextSimulatedId = currentSimulatedId + 1;
        } else {
          LOG.log(Level.WARNING, "Pathing logic error: In goal " + currentSimulatedId +
              ", but target " + endId + " is unexpected. Color: " + color);
          break;
        }
      } else if (currentSimulatedId > 0 && currentSimulatedId <= 52) {
        if (currentSimulatedId == ownerPreEntryPointId &&
            (endId == goalBaseForColor || (endId > goalBaseForColor && endId <= goalEndForColor)
                || endId == ownerEntryPointId)) {
          nextSimulatedId = goalBaseForColor;
        } else {
          int physicalNextOnRing = (currentSimulatedId % 52) + 1;
          nextSimulatedId = physicalNextOnRing;
        }
      } else if (currentSimulatedId == goalEndForColor) {
        LOG.fine("Piece " + currentSimulatedId + " is already at the end of its goal path for " + color);
        break;
      } else {
        LOG.log(Level.WARNING, "Pathing logic: Unhandled state. currentSimulatedId=" + currentSimulatedId +
            " endId=" + endId + " color=" + color);
        break;
      }

      if (nextSimulatedId != -1) {
        path.add(nextSimulatedId);
        currentSimulatedId = nextSimulatedId;
      } else {
        LOG.log(Level.SEVERE,
            "Pathing logic: nextSimulatedId remained -1. Breaking. current=" + currentSimulatedId + " target=" + endId);
        break;
      }
    }
    if (currentSimulatedId != endId && (path.isEmpty() || path.get(path.size() - 1) != endId)) {
      LOG.log(Level.WARNING, "Path incomplete or diverged. CurrentSim: " + currentSimulatedId + " Target: " + endId
          + ". Forcing target as last step.");
      if (path.isEmpty() || path.get(path.size() - 1) != endId) {
        if (endId != 0) {
          path.add(endId);
        }
      }
    }
    if (path.size() >= 2 && path.get(path.size() - 1).equals(path.get(path.size() - 2))) {
      path.remove(path.size() - 1);
    }

    LOG.log(Level.INFO, "Generated path for " + color + " from " + startId + " to " + endId + ": " + path);
    return path;
  }

  /**
   * Gets the board entry point position ID for a specific color.
   * <p>
   * Each player color has a designated entry point where pieces
   * enter the main board track from home.
   * </p>
   *
   * @param color the player color
   * @return the position ID of the entry point for the color
   */
  private int getEntryPoint(LudoColor color) {
    return switch (color) {
      case BLUE -> 1;
      case RED -> 14;
      case GREEN -> 27;
      case YELLOW -> 40;
    };
  }

  /**
   * Gets the goal area base position ID for a specific color.
   * <p>
   * Each player color has a designated goal area starting at
   * a specific base position ID.
   * </p>
   *
   * @param color the player color
   * @return the base position ID of the goal area for the color
   */
  private int getGoalBaseId(LudoColor color) {
    return switch (color) {
      case BLUE -> 53;
      case RED -> 59;
      case GREEN -> 65;
      case YELLOW -> 71;
    };
  }

  /**
   * Refreshes all game tokens and UI elements with current game state.
   * <p>
   * Updates player positions, board overlays, and status messages
   * to reflect the current game state from the gateway.
   * </p>
   */
  private void refreshTokens() {
    LOG.fine("Refreshing tokens on the board.");
    if (gateway == null) {
      LOG.warning("Gateway is null, cannot refresh tokens.");
      return;
    }
    try {
      List<PlayerView> updatedPlayers = gateway.players();
      view.setPlayers(updatedPlayers);
      view.setOverlays(gateway.boardOverlays());

      PlayerView currentPlayer = getCurrentPlayer();
      if (currentPlayer != null) {
        view.showStatusMessage(currentPlayer.playerName() + "'s turn");
      } else {
        LOG.info("No current player after token refresh, game might have ended or is in an intermediate state.");
      }
    } catch (Exception e) {
      LOG.log(Level.SEVERE, "Error refreshing tokens", e);
      Errors.handle("An error occurred while updating the game board.", e);
    }
  }

  /**
   * Determines if a piece has finished the game (reached the final goal
   * position).
   *
   * @param pos   the current position of the piece
   * @param color the color of the piece's owner
   * @return true if the piece has reached the final goal position
   */
  private boolean isPieceFinished(int pos, LudoColor color) {
    return pos == getGoalBaseId(color) + GOAL_LENGTH;
  }

  /**
   * Gets the current player whose turn it is to play.
   *
   * @return the PlayerView of the current player, or null if no player has the
   *         turn
   */
  private PlayerView getCurrentPlayer() {
    return gateway.players().stream().filter(PlayerView::hasTurn).findFirst().orElse(null);
  }
}